<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowing Wave</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <script>
        // Simplified Perlin noise implementation
        class ClassicalNoise {
            constructor() {
                this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                             [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                             [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                this.p = [];
                for(let i=0; i<256; i++) {
                    this.p[i] = Math.floor(Math.random()*256);
                }
                this.perm = [];
                for(let i=0; i<512; i++) {
                    this.perm[i]=this.p[i & 255];
                }
            }
            
            dot(g, x, y) {
                return g[0]*x + g[1]*y;
            }
            
            noise(xin, yin) {
                let n0, n1, n2;
                const F2 = 0.5*(Math.sqrt(3.0)-1.0);
                let s = (xin+yin)*F2;
                let i = Math.floor(xin+s);
                let j = Math.floor(yin+s);
                const G2 = (3.0-Math.sqrt(3.0))/6.0;
                let t = (i+j)*G2;
                let X0 = i-t;
                let Y0 = j-t;
                let x0 = xin-X0;
                let y0 = yin-Y0;
                let i1, j1;
                if(x0>y0) {i1=1; j1=0;}
                else {i1=0; j1=1;}
                let x1 = x0 - i1 + G2;
                let y1 = y0 - j1 + G2;
                let x2 = x0 - 1.0 + 2.0 * G2;
                let y2 = y0 - 1.0 + 2.0 * G2;
                let ii = i & 255;
                let jj = j & 255;
                let gi0 = this.perm[ii+this.perm[jj]] % 12;
                let gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
                let gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
                let t0 = 0.5 - x0*x0-y0*y0;
                if(t0<0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                let t1 = 0.5 - x1*x1-y1*y1;
                if(t1<0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                let t2 = 0.5 - x2*x2-y2*y2;
                if(t2<0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                return 70.0 * (n0 + n1 + n2);
            }
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const perlin = new ClassicalNoise();
        const variation = 0.0006;
        const amp = 180;
        const variators = [];
        const max_lines = 35;
        let canvasWidth, canvasHeight, start_y;

        for (let i = 0, u = 0; i < max_lines; i++, u += 0.03) {
            variators[i] = u;
        }

        function draw() {
            // Global hue that shifts slowly over time
            const globalHue = (Date.now() * 0.01) % 360;
            
            for (let i = 0; i <= max_lines; i++) {
                ctx.beginPath();
                ctx.moveTo(0, start_y);
                
                let lastY;
                for (let x = 0; x <= canvasWidth; x += 2) {
                    const y = perlin.noise(x * variation + variators[i], x * variation);
                    ctx.lineTo(x, start_y + amp * y);
                    lastY = y;
                }
                
                // Calculate opacity based on line position
                const linePosition = i / max_lines;
                const baseAlpha = 0.015 + (1 - linePosition) * 0.25;
                
                // All lines use the same hue, just different brightness
                const saturation = 70 + (1 - linePosition) * 30;
                const lightness = 50 + (1 - linePosition) * 30;
                
                if (i === 0) {
                    // Main glowing edge
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = `hsla(${globalHue}, ${saturation}%, ${lightness}%, 0.8)`;
                    ctx.strokeStyle = `hsla(${globalHue}, ${saturation}%, ${lightness}%, ${Math.min(baseAlpha * 8, 0.9)})`;
                    ctx.lineWidth = 2.5;
                } else {
                    // Contour lines - same hue, subtle variations
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = `hsla(${globalHue}, ${saturation}%, ${lightness}%, ${baseAlpha})`;
                    ctx.lineWidth = 0.8 + (1 - linePosition) * 0.5;
                }
                
                ctx.stroke();
                ctx.closePath();
                
                variators[i] += 0.0005;
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            draw();
            requestAnimationFrame(animate);
        }

        function resizeCanvas() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            start_y = canvasHeight * 0.42;
        }

        resizeCanvas();
        animate();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>